#!/usr/bin/env ruby 
require 'readline'
require 'lib/indextank_client'

@apiurl = nil
@idxname = nil
@api = nil
@index = nil
@data = {}
@start = 0
@len = 10
@data['start'] = @start
@data['len'] = @len



COMMANDS = {
    "url" => "[url] sets the api url",
    "list" => "lists all the indexes",
    "index" => "[index name] sets the inde name",
    "search" => "[query] searches the current index",
    "suggest" => "[prefix] suggests query terms starting with \"prefix\"",
    "add" => "[docid] creates a new document",
    "start" => "[n] show results starting from n",
    "len" => "[n] show n results",
    "set" => "shows current settings",
    "quit" => "exits this shell"
}

comp = proc { |s| COMMANDS.keys.grep( /^#{Regexp.escape(s)}/ ) }

Readline.completion_append_character = " "
Readline.completion_proc = comp

def get_prompt()
    if @idxname
        return @idxname + "> "
    else
        return "> "
    end
end

def command(line)
    args = line.split
    case args[0]
    when "url"
        @apiurl = args[1]
        @api = IndexTank::ApiClient.new @apiurl
        @data['api'] = @api
        printf "api url set to %s\n", @apiurl
    when "list"
        if !@api
            puts "no api url set yet. Did you run 'url' .. ?"
        else
            @api.list_indexes.each {|x| puts x.name}
        end
    when "index"
        if !args[1]
            puts @idxname
        else
            @idxname = args[1]
            @index = @api.get_index @idxname
            @data['index'] = @index
            printf "index set to %s\n", @idxname
        end
    when "search"
        query = args[1..args.length].join ' '
        results = @index.search(query, :start => @start, :len => @len)
        printf "%s results in %s seconds\n", results['matches'], results['search_time']
        results['results'].each {|doc|
            docid = doc['docid']
            printf "docid: #{docid}\n" 
        }
    when "suggest"
        query = args[1..args.length].join ' '
        results = @index.autocomplete(query)
        printf results['suggestions']
    when "add"
        if @index == nil
            puts 'set an index first'
        else
           if !args[1]
               docid = Readline.readline('enter docid (blank to abort):', true)
           else
               docid = args[1]
           end
           if docid.strip != ''
               doc = {}
               while true
                   field = Readline.readline('field name (or blank to end): ', true)
                   if field.strip == '' 
                       break
                   end
                   value = Readline.readline('field value: ', true)
                   doc[field] = value
               end
               @index.add_document(docid, doc)
               printf("added %s\n", docid)
           end
        end
    when "set"
        @data.each {|x| p x}
    when "len"
        @len = args[1].to_i
        @data['len'] = @len
    when "start"
        @start = args[1].to_i
        @data['start'] = @start
    when "help"
        printf "possible commands are:\n\n"
        COMMANDS.sort.each{|k,v| printf "%s %s\n", k, v}
    else
        puts 'no such command, try "help"'
    end
end

if File.exists? '.console'
    puts 'reading previous session from .console'
    @data = Marshal.load File.open('.console')
    @index = @data['index']
    @api = @data['api']
    @len = @data['len']
    @start = @data['start']
    
    if @index
        @idxname = @index.name
    end
end

while line = Readline.readline(get_prompt, true) and line != 'quit'
    begin
        command line
        f = File.open '.console', 'w'
        Marshal.dump(@data, f)
        f.close
    rescue Exception => e
        puts e
    end
end

